---
layout: post
title: Composition and Inheritance
---

>Prefer composition over inheritance

Software mantras can often lead developers into believing that design philosphies are laws that cannot be broken. In particular, favoring composition over inheritance tends to often be morphed into 'never inheritance.' And while this may be a backlash to generations of programs that caused developers to experience a kind of pain that can only be brought about by the intense coupling created by misapplying inheritance, the mantra is surprisingly robust, and has few exceptions.

### Composition is Natural

>How to break a problem down in order to build a solution up

Composition tends to align well with how humans like to understand the natural world. When we encounter a complex problem, a proven approach throughout history is to ask, 'Can we break this into smaller, approachable pieces?' This is the take smaller bites until you can chew approach. Composition allows us to gradually build up objects in our mind and creates clear delineations that allow for magical properties like the ability to test small units and their interactions with one another.

#### Composition in the Analog World

Creating software without the use of composition would be like trying to reason about a car as one mass entity. When dealing with the complexities of an automobile it helps to think in terms of its subsquent parts. And even those subsequent parts can be broken down further. An engine is responsible for turning a drive shaft. But an engine is made up of, among other things, a fuel injector for creating aerosolized gasoline, a spark plug for igniting the aerosol, and cylinders inside of pistons to take advantage of the force generated by the subsequent explosion. 

Breaking the engine down into it's components allows us not just to reason about how it works, but reason about how to design it in the first place. Instead of asking how to rotate a drive shaft we can ask, how can I efficiently create a force, and how can I use the force to accomplish a rotation. Someone answered "small explosions" and the rest is history.

#### Composition in the Digital World

When building a game like Tic Tac Toe composition plays a simlar role in reasoning about how to break a problem down in order to build a solution up. If we simply think of tic tac toe as a game with rules we have no idea where to start building a solution. But by breaking it down we can start to reason about the various components in play. The game takes place on a board. There are players that wield symbols. The game has rules, and so on. Each of these individual pieces may also be composed of smaller, more digestable (and testable!) pieces. 

Composition also promotes the use of polymorphism and duck typing to provide a variety of behaviors that can be injected as dependencies into higher level classes that expect a certain interface. These concepts promote generalized and robust solutions that follow another useful mantra of software design.

>Code to an interface, not an implementation

So with all of this praise for composition, are there use cases for inheritance, or is it an old dinosaur of software design mucking up the compilers of enterprise loved languages like Java and C#?

### The Dark Art of Inheritance

Inheritance provides a syntax supported, directed way to share behavior between classes. Inheritance achieves this by providing _automatic message forwarding_. Inheritance functions by allowing developers to create subclass-superclass relationships, or more naturally, parent-child relationships. Children of superclasses _inherit_ all of the behavior of the parent class, and add their own behavior into the mix. With this inheritance comes the responsibility to anticipate changes to the parent classes interface and thus the problems emerge.

>Inheritance creates strong coupling between the parent and child

Whenever changes to the parent classes public interface are performed, all child classes must be altered to accomodate the change. This means that developers must be extremely careful to manage their dependencies. Superclasses should only be abstracted when they are _unlikely to change_. From a similar perspective, if adhering to the dependency inversion principle, superclasses should be _less_ likely to change than their children. In addition, because children inherit _all_ of the public behavior of their parent, if we are to adhere to the Liskov substitution principle, we should only abstract superclasses when we are sure that the superclass behavior will be shared _and_ used by all of it's children.

So with a careful mindset, when should we proceed forward with the decision to utilize the seemingly dark art of inheritance?

#### Inheritance is special

Inheritance can be extremely useful when we desire _specialization_. If we discover that we have a class that has a single responsibility and our goal is to make a variety of different variations on that class that will all utilize the behavior provided by our SRP abiding parent, we have a strong argument to apply inheritance. 

The trick is to recognize when our classes are specializations of a generalization, and not when we simply want to share some behavior between classes.

Inheritance is a feature in many programming languages because it is useful to employ hierarchies when building data types. In Ruby, everything is an object. Whether it is a string or an integer, every value is an object and therefore is imbued with behavior. This provides a classic use case for inheritance, where it provides _consistency_ and a clear direction for the relationships among classes. All data types in Ruby forward messages that cannot be found within their own handlers to their superclass. This allowed the designers of the language to provide common behavior to _every_ data type in Ruby, and model everything as objects.

### Prefer is a Powerful Word

Inheritance can be powerful when employed correctly, but it's defacto usage for decades and the subsequent pain caused by the strong coupling it introduces have given developers a mantra that makes sense. Composition is a natural and unbelievably powerful technique to approach problems and build beautiful decoupled applications. But the word prefer should not be forgotten, and when we need nothing more than specialization, we should look to inheritance for assistance.
